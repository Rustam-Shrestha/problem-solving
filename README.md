# problem-solving
leetcode based problem solving for algorithm with java
# LeetCode Problem Solving Log  
## Day 1: Progress Summary

###  Completed Problems

1. **FizzBuzz**
   - **Approach 1**: Brute-force using conditional statements.
   - **Approach 2**: Bitwise optimization for divisibility checks.

2. **Palindrome Number**
   - Implemented reverse-half logic to avoid integer overflow and string conversion.
   - Ensured handling of negative numbers and trailing zero edge cases.

###  Notes
- Prioritized clean, efficient logic over language-based shortcuts.
- Strengthened familiarity with number manipulation and modular arithmetic.
- Reinforced understanding of basic input constraints and performance-aware coding.

###  Reflection
- Solid start: combined clarity, correctness, and multi-approach thinking.
- Maintained clean formatting and clear return conditions.


## Day 2: Progress Summary

### Completed Problems

1. **Longest Substring Without Repeating Characters**
   - **Approach**: Sliding window with HashMap for character index tracking.
   - Efficiently managed dynamic window bounds to avoid duplicate entries.
   - Achieved linear time complexity with constant-time updates.

2. **Two Sum**
   - **Approach**: HashMap for complement lookup.
   - Executed single-pass iteration with constant-time lookups.
   - Clean handling of edge cases including duplicates and negatives.

3. **Product of Array Except Self**
   - **Approach**: Dynamic programming using prefix and suffix product arrays.
   - Eliminated need for division to ensure robustness.
   - Efficient in both time and space, reused input for optimized output.

---

### Notes
- Reaffirmed skill in applying hash-based logic and index tracking.
- Practiced sliding window techniques for space-time optimization.
- Strengthened dynamic problem-solving through prefix/suffix insight.

---

### Reflection
- Demonstrated growth in strategic thinking and modular breakdown.
- Gained confidence in approaching pattern-based problems.
- Clear progress from brute-force toward algorithmic elegance.

